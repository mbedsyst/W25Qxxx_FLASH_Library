
FLASH_W25Q64.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000005b8  08000194  08000194  00001194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000100  0800074c  0800074c  0000174c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800084c  0800084c  00001854  2**0
                  CONTENTS
  4 .ARM          00000000  0800084c  0800084c  00001854  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800084c  08000854  00001854  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800084c  0800084c  0000184c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08000850  08000850  00001850  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00001854  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000001c  20000000  08000854  00002000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000001c  08000854  0000201c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00001854  2**0
                  CONTENTS, READONLY
 12 .debug_info   000011f0  00000000  00000000  00001884  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000065d  00000000  00000000  00002a74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000001a0  00000000  00000000  000030d8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00000116  00000000  00000000  00003278  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000e20f  00000000  00000000  0000338e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00002365  00000000  00000000  0001159d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0004fe9d  00000000  00000000  00013902  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  0006379f  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000048c  00000000  00000000  000637e4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000060  00000000  00000000  00063c70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000194 <__do_global_dtors_aux>:
 8000194:	b510      	push	{r4, lr}
 8000196:	4c05      	ldr	r4, [pc, #20]	@ (80001ac <__do_global_dtors_aux+0x18>)
 8000198:	7823      	ldrb	r3, [r4, #0]
 800019a:	b933      	cbnz	r3, 80001aa <__do_global_dtors_aux+0x16>
 800019c:	4b04      	ldr	r3, [pc, #16]	@ (80001b0 <__do_global_dtors_aux+0x1c>)
 800019e:	b113      	cbz	r3, 80001a6 <__do_global_dtors_aux+0x12>
 80001a0:	4804      	ldr	r0, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x20>)
 80001a2:	f3af 8000 	nop.w
 80001a6:	2301      	movs	r3, #1
 80001a8:	7023      	strb	r3, [r4, #0]
 80001aa:	bd10      	pop	{r4, pc}
 80001ac:	20000000 	.word	0x20000000
 80001b0:	00000000 	.word	0x00000000
 80001b4:	08000734 	.word	0x08000734

080001b8 <frame_dummy>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	4b03      	ldr	r3, [pc, #12]	@ (80001c8 <frame_dummy+0x10>)
 80001bc:	b11b      	cbz	r3, 80001c6 <frame_dummy+0xe>
 80001be:	4903      	ldr	r1, [pc, #12]	@ (80001cc <frame_dummy+0x14>)
 80001c0:	4803      	ldr	r0, [pc, #12]	@ (80001d0 <frame_dummy+0x18>)
 80001c2:	f3af 8000 	nop.w
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	20000004 	.word	0x20000004
 80001d0:	08000734 	.word	0x08000734

080001d4 <LED_Init>:
#include "LED.h"

void LED_Init(void)
{
 80001d4:	b480      	push	{r7}
 80001d6:	af00      	add	r7, sp, #0
    RCC->AHB1ENR	|= RCC_AHB1ENR_GPIOAEN;
 80001d8:	4b14      	ldr	r3, [pc, #80]	@ (800022c <LED_Init+0x58>)
 80001da:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80001dc:	4a13      	ldr	r2, [pc, #76]	@ (800022c <LED_Init+0x58>)
 80001de:	f043 0301 	orr.w	r3, r3, #1
 80001e2:	6313      	str	r3, [r2, #48]	@ 0x30
    GPIOA->MODER	&=~(3U<<10);  	// Clear mode bits for PA5
 80001e4:	4b12      	ldr	r3, [pc, #72]	@ (8000230 <LED_Init+0x5c>)
 80001e6:	681b      	ldr	r3, [r3, #0]
 80001e8:	4a11      	ldr	r2, [pc, #68]	@ (8000230 <LED_Init+0x5c>)
 80001ea:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
 80001ee:	6013      	str	r3, [r2, #0]
    GPIOA->MODER	|= (1U<<10);   	// Set PA5 as output (01)
 80001f0:	4b0f      	ldr	r3, [pc, #60]	@ (8000230 <LED_Init+0x5c>)
 80001f2:	681b      	ldr	r3, [r3, #0]
 80001f4:	4a0e      	ldr	r2, [pc, #56]	@ (8000230 <LED_Init+0x5c>)
 80001f6:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 80001fa:	6013      	str	r3, [r2, #0]
    GPIOA->OTYPER	&=~(1U<<5);     // Set PA5 as push-pull
 80001fc:	4b0c      	ldr	r3, [pc, #48]	@ (8000230 <LED_Init+0x5c>)
 80001fe:	685b      	ldr	r3, [r3, #4]
 8000200:	4a0b      	ldr	r2, [pc, #44]	@ (8000230 <LED_Init+0x5c>)
 8000202:	f023 0320 	bic.w	r3, r3, #32
 8000206:	6053      	str	r3, [r2, #4]
    GPIOA->OSPEEDR	|= (3U<<10); 	// High speed for PA5
 8000208:	4b09      	ldr	r3, [pc, #36]	@ (8000230 <LED_Init+0x5c>)
 800020a:	689b      	ldr	r3, [r3, #8]
 800020c:	4a08      	ldr	r2, [pc, #32]	@ (8000230 <LED_Init+0x5c>)
 800020e:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 8000212:	6093      	str	r3, [r2, #8]
    GPIOA->PUPDR	&=~(3U<<10);  	// No pull-up/pull-down for PA5
 8000214:	4b06      	ldr	r3, [pc, #24]	@ (8000230 <LED_Init+0x5c>)
 8000216:	68db      	ldr	r3, [r3, #12]
 8000218:	4a05      	ldr	r2, [pc, #20]	@ (8000230 <LED_Init+0x5c>)
 800021a:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
 800021e:	60d3      	str	r3, [r2, #12]
}
 8000220:	bf00      	nop
 8000222:	46bd      	mov	sp, r7
 8000224:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000228:	4770      	bx	lr
 800022a:	bf00      	nop
 800022c:	40023800 	.word	0x40023800
 8000230:	40020000 	.word	0x40020000

08000234 <LED_Toggle>:
{
	GPIOA->ODR &= ~(1<<5);
}

void LED_Toggle(void)
{
 8000234:	b480      	push	{r7}
 8000236:	af00      	add	r7, sp, #0
    GPIOA->ODR ^= (1U << 5);
 8000238:	4b05      	ldr	r3, [pc, #20]	@ (8000250 <LED_Toggle+0x1c>)
 800023a:	695b      	ldr	r3, [r3, #20]
 800023c:	4a04      	ldr	r2, [pc, #16]	@ (8000250 <LED_Toggle+0x1c>)
 800023e:	f083 0320 	eor.w	r3, r3, #32
 8000242:	6153      	str	r3, [r2, #20]
}
 8000244:	bf00      	nop
 8000246:	46bd      	mov	sp, r7
 8000248:	f85d 7b04 	ldr.w	r7, [sp], #4
 800024c:	4770      	bx	lr
 800024e:	bf00      	nop
 8000250:	40020000 	.word	0x40020000

08000254 <SPI2_Init>:
 *		SPI2_SCK	- PB13
 *		SPI2_NSS	- PB12
 */

void SPI2_Init(void)
{
 8000254:	b580      	push	{r7, lr}
 8000256:	af00      	add	r7, sp, #0
	// Enable clock for GPIO Port B
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
 8000258:	4b16      	ldr	r3, [pc, #88]	@ (80002b4 <SPI2_Init+0x60>)
 800025a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800025c:	4a15      	ldr	r2, [pc, #84]	@ (80002b4 <SPI2_Init+0x60>)
 800025e:	f043 0302 	orr.w	r3, r3, #2
 8000262:	6313      	str	r3, [r2, #48]	@ 0x30
    // Enable clock SPI2 peripheral
	RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;
 8000264:	4b13      	ldr	r3, [pc, #76]	@ (80002b4 <SPI2_Init+0x60>)
 8000266:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000268:	4a12      	ldr	r2, [pc, #72]	@ (80002b4 <SPI2_Init+0x60>)
 800026a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800026e:	6413      	str	r3, [r2, #64]	@ 0x40

	// Configure PB13, PB14, PB15 as Alternate Function for SPI2
	GPIOB->MODER &= ~(GPIO_MODER_MODE12 | GPIO_MODER_MODE13 | GPIO_MODER_MODE14 | GPIO_MODER_MODE15);
 8000270:	4b11      	ldr	r3, [pc, #68]	@ (80002b8 <SPI2_Init+0x64>)
 8000272:	681b      	ldr	r3, [r3, #0]
 8000274:	4a10      	ldr	r2, [pc, #64]	@ (80002b8 <SPI2_Init+0x64>)
 8000276:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 800027a:	6013      	str	r3, [r2, #0]
	GPIOB->MODER |= (GPIO_MODER_MODE12_0 | GPIO_MODER_MODE13_1 | GPIO_MODER_MODE14_1 | GPIO_MODER_MODE15_1);
 800027c:	4b0e      	ldr	r3, [pc, #56]	@ (80002b8 <SPI2_Init+0x64>)
 800027e:	681b      	ldr	r3, [r3, #0]
 8000280:	4a0d      	ldr	r2, [pc, #52]	@ (80002b8 <SPI2_Init+0x64>)
 8000282:	f043 4329 	orr.w	r3, r3, #2835349504	@ 0xa9000000
 8000286:	6013      	str	r3, [r2, #0]
	GPIOB->AFR[1] |= ((5 << 20) | (5 << 24) | (5 << 28));
 8000288:	4b0b      	ldr	r3, [pc, #44]	@ (80002b8 <SPI2_Init+0x64>)
 800028a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800028c:	4a0a      	ldr	r2, [pc, #40]	@ (80002b8 <SPI2_Init+0x64>)
 800028e:	f043 43aa 	orr.w	r3, r3, #1426063360	@ 0x55000000
 8000292:	f443 03a0 	orr.w	r3, r3, #5242880	@ 0x500000
 8000296:	6253      	str	r3, [r2, #36]	@ 0x24

	// Pull CS High
	SPI2_DeselectSlave();
 8000298:	f000 f820 	bl	80002dc <SPI2_DeselectSlave>

	// Configure SPI2 in master mode, baud rate = fPCLK / 16, CPOL = 0, CPHA = 0, 8-bit data format
	SPI2->CR1 = SPI_CR1_MSTR | SPI_CR1_BR_1 | SPI_CR1_SSI | SPI_CR1_SSM;
 800029c:	4b07      	ldr	r3, [pc, #28]	@ (80002bc <SPI2_Init+0x68>)
 800029e:	f44f 7245 	mov.w	r2, #788	@ 0x314
 80002a2:	601a      	str	r2, [r3, #0]
	// Enable SPI2
	SPI2->CR1 |= SPI_CR1_SPE;
 80002a4:	4b05      	ldr	r3, [pc, #20]	@ (80002bc <SPI2_Init+0x68>)
 80002a6:	681b      	ldr	r3, [r3, #0]
 80002a8:	4a04      	ldr	r2, [pc, #16]	@ (80002bc <SPI2_Init+0x68>)
 80002aa:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80002ae:	6013      	str	r3, [r2, #0]
}
 80002b0:	bf00      	nop
 80002b2:	bd80      	pop	{r7, pc}
 80002b4:	40023800 	.word	0x40023800
 80002b8:	40020400 	.word	0x40020400
 80002bc:	40003800 	.word	0x40003800

080002c0 <SPI2_SelectSlave>:

void SPI2_SelectSlave(void)
{
 80002c0:	b480      	push	{r7}
 80002c2:	af00      	add	r7, sp, #0
	// Pull CS low
	GPIOB->BSRR = (1 << 28);
 80002c4:	4b04      	ldr	r3, [pc, #16]	@ (80002d8 <SPI2_SelectSlave+0x18>)
 80002c6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80002ca:	619a      	str	r2, [r3, #24]
}
 80002cc:	bf00      	nop
 80002ce:	46bd      	mov	sp, r7
 80002d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002d4:	4770      	bx	lr
 80002d6:	bf00      	nop
 80002d8:	40020400 	.word	0x40020400

080002dc <SPI2_DeselectSlave>:

void SPI2_DeselectSlave(void)
{
 80002dc:	b480      	push	{r7}
 80002de:	af00      	add	r7, sp, #0
    // Pull CS high
    GPIOB->BSRR = (1 << 12);
 80002e0:	4b04      	ldr	r3, [pc, #16]	@ (80002f4 <SPI2_DeselectSlave+0x18>)
 80002e2:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 80002e6:	619a      	str	r2, [r3, #24]
}
 80002e8:	bf00      	nop
 80002ea:	46bd      	mov	sp, r7
 80002ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80002f0:	4770      	bx	lr
 80002f2:	bf00      	nop
 80002f4:	40020400 	.word	0x40020400

080002f8 <SPI2_TransmitReceiveByte>:

uint8_t SPI2_TransmitReceiveByte(uint8_t data)
{
 80002f8:	b480      	push	{r7}
 80002fa:	b083      	sub	sp, #12
 80002fc:	af00      	add	r7, sp, #0
 80002fe:	4603      	mov	r3, r0
 8000300:	71fb      	strb	r3, [r7, #7]
    // Wait until TXE (Transmit buffer empty)
    while(!(SPI2->SR & SPI_SR_TXE));
 8000302:	bf00      	nop
 8000304:	4b0c      	ldr	r3, [pc, #48]	@ (8000338 <SPI2_TransmitReceiveByte+0x40>)
 8000306:	689b      	ldr	r3, [r3, #8]
 8000308:	f003 0302 	and.w	r3, r3, #2
 800030c:	2b00      	cmp	r3, #0
 800030e:	d0f9      	beq.n	8000304 <SPI2_TransmitReceiveByte+0xc>
    // Send data
    SPI2->DR = data;
 8000310:	4a09      	ldr	r2, [pc, #36]	@ (8000338 <SPI2_TransmitReceiveByte+0x40>)
 8000312:	79fb      	ldrb	r3, [r7, #7]
 8000314:	60d3      	str	r3, [r2, #12]
    // Wait until RXNE (Receive buffer not empty)
    while(!(SPI2->SR & SPI_SR_RXNE));
 8000316:	bf00      	nop
 8000318:	4b07      	ldr	r3, [pc, #28]	@ (8000338 <SPI2_TransmitReceiveByte+0x40>)
 800031a:	689b      	ldr	r3, [r3, #8]
 800031c:	f003 0301 	and.w	r3, r3, #1
 8000320:	2b00      	cmp	r3, #0
 8000322:	d0f9      	beq.n	8000318 <SPI2_TransmitReceiveByte+0x20>
    // Return received data
    return (uint8_t)(SPI2->DR);
 8000324:	4b04      	ldr	r3, [pc, #16]	@ (8000338 <SPI2_TransmitReceiveByte+0x40>)
 8000326:	68db      	ldr	r3, [r3, #12]
 8000328:	b2db      	uxtb	r3, r3
}
 800032a:	4618      	mov	r0, r3
 800032c:	370c      	adds	r7, #12
 800032e:	46bd      	mov	sp, r7
 8000330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000334:	4770      	bx	lr
 8000336:	bf00      	nop
 8000338:	40003800 	.word	0x40003800

0800033c <SPI2_TransmitReceive_MultiByte>:

void SPI2_TransmitReceive_MultiByte(uint8_t *txData, uint8_t *rxData, uint16_t size)
{
 800033c:	b480      	push	{r7}
 800033e:	b087      	sub	sp, #28
 8000340:	af00      	add	r7, sp, #0
 8000342:	60f8      	str	r0, [r7, #12]
 8000344:	60b9      	str	r1, [r7, #8]
 8000346:	4613      	mov	r3, r2
 8000348:	80fb      	strh	r3, [r7, #6]
    uint16_t i = 0;
 800034a:	2300      	movs	r3, #0
 800034c:	82fb      	strh	r3, [r7, #22]
    while (i < size)
 800034e:	e021      	b.n	8000394 <SPI2_TransmitReceive_MultiByte+0x58>
    {
        // Wait until TXE (Transmit buffer empty)
        while (!(SPI2->SR & SPI_SR_TXE));
 8000350:	bf00      	nop
 8000352:	4b16      	ldr	r3, [pc, #88]	@ (80003ac <SPI2_TransmitReceive_MultiByte+0x70>)
 8000354:	689b      	ldr	r3, [r3, #8]
 8000356:	f003 0302 	and.w	r3, r3, #2
 800035a:	2b00      	cmp	r3, #0
 800035c:	d0f9      	beq.n	8000352 <SPI2_TransmitReceive_MultiByte+0x16>
        // Transmit data
        SPI2->DR = txData[i];
 800035e:	8afb      	ldrh	r3, [r7, #22]
 8000360:	68fa      	ldr	r2, [r7, #12]
 8000362:	4413      	add	r3, r2
 8000364:	781a      	ldrb	r2, [r3, #0]
 8000366:	4b11      	ldr	r3, [pc, #68]	@ (80003ac <SPI2_TransmitReceive_MultiByte+0x70>)
 8000368:	60da      	str	r2, [r3, #12]
        // Wait until RXNE (Receive buffer not empty)
        while (!(SPI2->SR & SPI_SR_RXNE));
 800036a:	bf00      	nop
 800036c:	4b0f      	ldr	r3, [pc, #60]	@ (80003ac <SPI2_TransmitReceive_MultiByte+0x70>)
 800036e:	689b      	ldr	r3, [r3, #8]
 8000370:	f003 0301 	and.w	r3, r3, #1
 8000374:	2b00      	cmp	r3, #0
 8000376:	d0f9      	beq.n	800036c <SPI2_TransmitReceive_MultiByte+0x30>
        // Read received data, even if rxData is NULL (to clear RXNE flag)
        uint8_t receivedByte = (uint8_t)(SPI2->DR);
 8000378:	4b0c      	ldr	r3, [pc, #48]	@ (80003ac <SPI2_TransmitReceive_MultiByte+0x70>)
 800037a:	68db      	ldr	r3, [r3, #12]
 800037c:	757b      	strb	r3, [r7, #21]
        // Store received data only if rxData is not NULL
        if (rxData != NULL)
 800037e:	68bb      	ldr	r3, [r7, #8]
 8000380:	2b00      	cmp	r3, #0
 8000382:	d004      	beq.n	800038e <SPI2_TransmitReceive_MultiByte+0x52>
        {
            rxData[i] = receivedByte;
 8000384:	8afb      	ldrh	r3, [r7, #22]
 8000386:	68ba      	ldr	r2, [r7, #8]
 8000388:	4413      	add	r3, r2
 800038a:	7d7a      	ldrb	r2, [r7, #21]
 800038c:	701a      	strb	r2, [r3, #0]
        }
        i++;
 800038e:	8afb      	ldrh	r3, [r7, #22]
 8000390:	3301      	adds	r3, #1
 8000392:	82fb      	strh	r3, [r7, #22]
    while (i < size)
 8000394:	8afa      	ldrh	r2, [r7, #22]
 8000396:	88fb      	ldrh	r3, [r7, #6]
 8000398:	429a      	cmp	r2, r3
 800039a:	d3d9      	bcc.n	8000350 <SPI2_TransmitReceive_MultiByte+0x14>
    }
}
 800039c:	bf00      	nop
 800039e:	bf00      	nop
 80003a0:	371c      	adds	r7, #28
 80003a2:	46bd      	mov	sp, r7
 80003a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003a8:	4770      	bx	lr
 80003aa:	bf00      	nop
 80003ac:	40003800 	.word	0x40003800

080003b0 <delay_ms>:
#include "SYSTICK.h"

void delay_ms(uint32_t ms)
{
 80003b0:	b480      	push	{r7}
 80003b2:	b085      	sub	sp, #20
 80003b4:	af00      	add	r7, sp, #0
 80003b6:	6078      	str	r0, [r7, #4]
	uint32_t i;
	SysTick->CTRL |= (1<<0) | (1<<2) ;
 80003b8:	4b13      	ldr	r3, [pc, #76]	@ (8000408 <delay_ms+0x58>)
 80003ba:	681b      	ldr	r3, [r3, #0]
 80003bc:	4a12      	ldr	r2, [pc, #72]	@ (8000408 <delay_ms+0x58>)
 80003be:	f043 0305 	orr.w	r3, r3, #5
 80003c2:	6013      	str	r3, [r2, #0]
	SysTick->LOAD  = 15999;
 80003c4:	4b10      	ldr	r3, [pc, #64]	@ (8000408 <delay_ms+0x58>)
 80003c6:	f643 627f 	movw	r2, #15999	@ 0x3e7f
 80003ca:	605a      	str	r2, [r3, #4]
	for(i=0; i<ms; i++)
 80003cc:	2300      	movs	r3, #0
 80003ce:	60fb      	str	r3, [r7, #12]
 80003d0:	e009      	b.n	80003e6 <delay_ms+0x36>
	{
		while(!(SysTick->CTRL & (1<<16)));
 80003d2:	bf00      	nop
 80003d4:	4b0c      	ldr	r3, [pc, #48]	@ (8000408 <delay_ms+0x58>)
 80003d6:	681b      	ldr	r3, [r3, #0]
 80003d8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80003dc:	2b00      	cmp	r3, #0
 80003de:	d0f9      	beq.n	80003d4 <delay_ms+0x24>
	for(i=0; i<ms; i++)
 80003e0:	68fb      	ldr	r3, [r7, #12]
 80003e2:	3301      	adds	r3, #1
 80003e4:	60fb      	str	r3, [r7, #12]
 80003e6:	68fa      	ldr	r2, [r7, #12]
 80003e8:	687b      	ldr	r3, [r7, #4]
 80003ea:	429a      	cmp	r2, r3
 80003ec:	d3f1      	bcc.n	80003d2 <delay_ms+0x22>
	}
	SysTick->CTRL &=~(1U<<0) ;
 80003ee:	4b06      	ldr	r3, [pc, #24]	@ (8000408 <delay_ms+0x58>)
 80003f0:	681b      	ldr	r3, [r3, #0]
 80003f2:	4a05      	ldr	r2, [pc, #20]	@ (8000408 <delay_ms+0x58>)
 80003f4:	f023 0301 	bic.w	r3, r3, #1
 80003f8:	6013      	str	r3, [r2, #0]
}
 80003fa:	bf00      	nop
 80003fc:	3714      	adds	r7, #20
 80003fe:	46bd      	mov	sp, r7
 8000400:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop
 8000408:	e000e010 	.word	0xe000e010

0800040c <Compute_UART_Baud>:
#define APB1_CLK		SYS_FREQ

void UART2_Write(int ch);

static uint16_t Compute_UART_Baud(uint32_t periph_clk, uint32_t baudrate)
{
 800040c:	b480      	push	{r7}
 800040e:	b083      	sub	sp, #12
 8000410:	af00      	add	r7, sp, #0
 8000412:	6078      	str	r0, [r7, #4]
 8000414:	6039      	str	r1, [r7, #0]
	return ((periph_clk + (baudrate/2U))/baudrate);
 8000416:	683b      	ldr	r3, [r7, #0]
 8000418:	085a      	lsrs	r2, r3, #1
 800041a:	687b      	ldr	r3, [r7, #4]
 800041c:	441a      	add	r2, r3
 800041e:	683b      	ldr	r3, [r7, #0]
 8000420:	fbb2 f3f3 	udiv	r3, r2, r3
 8000424:	b29b      	uxth	r3, r3
}
 8000426:	4618      	mov	r0, r3
 8000428:	370c      	adds	r7, #12
 800042a:	46bd      	mov	sp, r7
 800042c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000430:	4770      	bx	lr
	...

08000434 <UART2_SetBaudRate>:

static void UART2_SetBaudRate(uint32_t periph_clk, uint32_t baudrate)
{
 8000434:	b580      	push	{r7, lr}
 8000436:	b082      	sub	sp, #8
 8000438:	af00      	add	r7, sp, #0
 800043a:	6078      	str	r0, [r7, #4]
 800043c:	6039      	str	r1, [r7, #0]
	USART2->BRR = Compute_UART_Baud(periph_clk,baudrate);
 800043e:	6839      	ldr	r1, [r7, #0]
 8000440:	6878      	ldr	r0, [r7, #4]
 8000442:	f7ff ffe3 	bl	800040c <Compute_UART_Baud>
 8000446:	4603      	mov	r3, r0
 8000448:	461a      	mov	r2, r3
 800044a:	4b03      	ldr	r3, [pc, #12]	@ (8000458 <UART2_SetBaudRate+0x24>)
 800044c:	609a      	str	r2, [r3, #8]
}
 800044e:	bf00      	nop
 8000450:	3708      	adds	r7, #8
 8000452:	46bd      	mov	sp, r7
 8000454:	bd80      	pop	{r7, pc}
 8000456:	bf00      	nop
 8000458:	40004400 	.word	0x40004400

0800045c <UART2_Init>:

void UART2_Init(void)
{
 800045c:	b580      	push	{r7, lr}
 800045e:	af00      	add	r7, sp, #0
	/*Enable clock access to GPIOA*/
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
 8000460:	4b18      	ldr	r3, [pc, #96]	@ (80004c4 <UART2_Init+0x68>)
 8000462:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000464:	4a17      	ldr	r2, [pc, #92]	@ (80004c4 <UART2_Init+0x68>)
 8000466:	f043 0301 	orr.w	r3, r3, #1
 800046a:	6313      	str	r3, [r2, #48]	@ 0x30
	/*Enable clock access to UART2*/
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
 800046c:	4b15      	ldr	r3, [pc, #84]	@ (80004c4 <UART2_Init+0x68>)
 800046e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000470:	4a14      	ldr	r2, [pc, #80]	@ (80004c4 <UART2_Init+0x68>)
 8000472:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000476:	6413      	str	r3, [r2, #64]	@ 0x40
	/*Set PA2 mode to alternate function mode */
	GPIOA->MODER &=~(1U<<4);
 8000478:	4b13      	ldr	r3, [pc, #76]	@ (80004c8 <UART2_Init+0x6c>)
 800047a:	681b      	ldr	r3, [r3, #0]
 800047c:	4a12      	ldr	r2, [pc, #72]	@ (80004c8 <UART2_Init+0x6c>)
 800047e:	f023 0310 	bic.w	r3, r3, #16
 8000482:	6013      	str	r3, [r2, #0]
	GPIOA->MODER |=(1U<<5);
 8000484:	4b10      	ldr	r3, [pc, #64]	@ (80004c8 <UART2_Init+0x6c>)
 8000486:	681b      	ldr	r3, [r3, #0]
 8000488:	4a0f      	ldr	r2, [pc, #60]	@ (80004c8 <UART2_Init+0x6c>)
 800048a:	f043 0320 	orr.w	r3, r3, #32
 800048e:	6013      	str	r3, [r2, #0]
	/*Set PA2 alternate function type to UART_TX(AF07)*/
	GPIOA->AFR[0] |=(0x7<<8);
 8000490:	4b0d      	ldr	r3, [pc, #52]	@ (80004c8 <UART2_Init+0x6c>)
 8000492:	6a1b      	ldr	r3, [r3, #32]
 8000494:	4a0c      	ldr	r2, [pc, #48]	@ (80004c8 <UART2_Init+0x6c>)
 8000496:	f443 63e0 	orr.w	r3, r3, #1792	@ 0x700
 800049a:	6213      	str	r3, [r2, #32]
	/*Configure Baud Rate*/
	UART2_SetBaudRate(APB1_CLK,UART_BAUDRATE);
 800049c:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
 80004a0:	480a      	ldr	r0, [pc, #40]	@ (80004cc <UART2_Init+0x70>)
 80004a2:	f7ff ffc7 	bl	8000434 <UART2_SetBaudRate>
	/*Configure the Transfer directions*/
	USART2->CR1 |= (USART_CR1_TE | USART_CR1_RE);
 80004a6:	4b0a      	ldr	r3, [pc, #40]	@ (80004d0 <UART2_Init+0x74>)
 80004a8:	68db      	ldr	r3, [r3, #12]
 80004aa:	4a09      	ldr	r2, [pc, #36]	@ (80004d0 <UART2_Init+0x74>)
 80004ac:	f043 030c 	orr.w	r3, r3, #12
 80004b0:	60d3      	str	r3, [r2, #12]
	/*Enable UART module*/
	USART2->CR1 |= USART_CR1_UE;
 80004b2:	4b07      	ldr	r3, [pc, #28]	@ (80004d0 <UART2_Init+0x74>)
 80004b4:	68db      	ldr	r3, [r3, #12]
 80004b6:	4a06      	ldr	r2, [pc, #24]	@ (80004d0 <UART2_Init+0x74>)
 80004b8:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80004bc:	60d3      	str	r3, [r2, #12]
}
 80004be:	bf00      	nop
 80004c0:	bd80      	pop	{r7, pc}
 80004c2:	bf00      	nop
 80004c4:	40023800 	.word	0x40023800
 80004c8:	40020000 	.word	0x40020000
 80004cc:	00f42400 	.word	0x00f42400
 80004d0:	40004400 	.word	0x40004400

080004d4 <W25Q_WriteEnable>:
#include "W25Qxx.h"

static void W25Q_WriteEnable(void)
{
 80004d4:	b580      	push	{r7, lr}
 80004d6:	af00      	add	r7, sp, #0
	SPI2_SelectSlave();
 80004d8:	f7ff fef2 	bl	80002c0 <SPI2_SelectSlave>
	SPI2_TransmitReceiveByte(ENABLE_WRITE);
 80004dc:	2006      	movs	r0, #6
 80004de:	f7ff ff0b 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_DeselectSlave();
 80004e2:	f7ff fefb 	bl	80002dc <SPI2_DeselectSlave>
	delay_ms(10);
 80004e6:	200a      	movs	r0, #10
 80004e8:	f7ff ff62 	bl	80003b0 <delay_ms>
}
 80004ec:	bf00      	nop
 80004ee:	bd80      	pop	{r7, pc}

080004f0 <W25Q_WriteDisable>:

static void W25Q_WriteDisable(void)
{
 80004f0:	b580      	push	{r7, lr}
 80004f2:	af00      	add	r7, sp, #0
	SPI2_SelectSlave();
 80004f4:	f7ff fee4 	bl	80002c0 <SPI2_SelectSlave>
	SPI2_TransmitReceiveByte(DISABLE_WRITE);
 80004f8:	2004      	movs	r0, #4
 80004fa:	f7ff fefd 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_DeselectSlave();
 80004fe:	f7ff feed 	bl	80002dc <SPI2_DeselectSlave>
	delay_ms(10);
 8000502:	200a      	movs	r0, #10
 8000504:	f7ff ff54 	bl	80003b0 <delay_ms>
}
 8000508:	bf00      	nop
 800050a:	bd80      	pop	{r7, pc}

0800050c <W25Q_Reset>:

static void W25Q_Reset(void)
{
 800050c:	b580      	push	{r7, lr}
 800050e:	af00      	add	r7, sp, #0
	SPI2_SelectSlave();
 8000510:	f7ff fed6 	bl	80002c0 <SPI2_SelectSlave>
	SPI2_TransmitReceiveByte(ENABLE_RESET);
 8000514:	2066      	movs	r0, #102	@ 0x66
 8000516:	f7ff feef 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte(EXECUTE_RESET);
 800051a:	2099      	movs	r0, #153	@ 0x99
 800051c:	f7ff feec 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_DeselectSlave();
 8000520:	f7ff fedc 	bl	80002dc <SPI2_DeselectSlave>
	delay_ms(100);
 8000524:	2064      	movs	r0, #100	@ 0x64
 8000526:	f7ff ff43 	bl	80003b0 <delay_ms>
}
 800052a:	bf00      	nop
 800052c:	bd80      	pop	{r7, pc}

0800052e <W25Q_Init>:

void W25Q_Init(void)
{
 800052e:	b580      	push	{r7, lr}
 8000530:	af00      	add	r7, sp, #0
	SPI2_Init();
 8000532:	f7ff fe8f 	bl	8000254 <SPI2_Init>
	W25Q_Reset();
 8000536:	f7ff ffe9 	bl	800050c <W25Q_Reset>
}
 800053a:	bf00      	nop
 800053c:	bd80      	pop	{r7, pc}

0800053e <W25Q_WritePage>:
	}
	SPI2_DeselectSlave();
}

void W25Q_WritePage(uint32_t startPage, uint16_t offset, uint32_t size, uint8_t *data)
{
 800053e:	b580      	push	{r7, lr}
 8000540:	b086      	sub	sp, #24
 8000542:	af00      	add	r7, sp, #0
 8000544:	60f8      	str	r0, [r7, #12]
 8000546:	607a      	str	r2, [r7, #4]
 8000548:	603b      	str	r3, [r7, #0]
 800054a:	460b      	mov	r3, r1
 800054c:	817b      	strh	r3, [r7, #10]

	uint32_t memAddress = (startPage * 256) + offset;
 800054e:	68fb      	ldr	r3, [r7, #12]
 8000550:	021a      	lsls	r2, r3, #8
 8000552:	897b      	ldrh	r3, [r7, #10]
 8000554:	4413      	add	r3, r2
 8000556:	617b      	str	r3, [r7, #20]
	W25Q_WriteEnable();
 8000558:	f7ff ffbc 	bl	80004d4 <W25Q_WriteEnable>
	SPI2_SelectSlave();
 800055c:	f7ff feb0 	bl	80002c0 <SPI2_SelectSlave>
	SPI2_TransmitReceiveByte(PAGE_WRITE);
 8000560:	2002      	movs	r0, #2
 8000562:	f7ff fec9 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte((memAddress >> 16) & 0xFF);
 8000566:	697b      	ldr	r3, [r7, #20]
 8000568:	0c1b      	lsrs	r3, r3, #16
 800056a:	b2db      	uxtb	r3, r3
 800056c:	4618      	mov	r0, r3
 800056e:	f7ff fec3 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte((memAddress >> 8) & 0xFF);
 8000572:	697b      	ldr	r3, [r7, #20]
 8000574:	0a1b      	lsrs	r3, r3, #8
 8000576:	b2db      	uxtb	r3, r3
 8000578:	4618      	mov	r0, r3
 800057a:	f7ff febd 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte((memAddress) & 0xFF);
 800057e:	697b      	ldr	r3, [r7, #20]
 8000580:	b2db      	uxtb	r3, r3
 8000582:	4618      	mov	r0, r3
 8000584:	f7ff feb8 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceive_MultiByte(data, NULL, size);
 8000588:	687b      	ldr	r3, [r7, #4]
 800058a:	b29b      	uxth	r3, r3
 800058c:	461a      	mov	r2, r3
 800058e:	2100      	movs	r1, #0
 8000590:	6838      	ldr	r0, [r7, #0]
 8000592:	f7ff fed3 	bl	800033c <SPI2_TransmitReceive_MultiByte>
	SPI2_DeselectSlave();
 8000596:	f7ff fea1 	bl	80002dc <SPI2_DeselectSlave>
	W25Q_WriteDisable();
 800059a:	f7ff ffa9 	bl	80004f0 <W25Q_WriteDisable>
	delay_ms(5);
 800059e:	2005      	movs	r0, #5
 80005a0:	f7ff ff06 	bl	80003b0 <delay_ms>
}
 80005a4:	bf00      	nop
 80005a6:	3718      	adds	r7, #24
 80005a8:	46bd      	mov	sp, r7
 80005aa:	bd80      	pop	{r7, pc}

080005ac <W25Q_EraseSector>:

void W25Q_EraseSector(uint8_t block, uint8_t sector)
{
 80005ac:	b580      	push	{r7, lr}
 80005ae:	b084      	sub	sp, #16
 80005b0:	af00      	add	r7, sp, #0
 80005b2:	4603      	mov	r3, r0
 80005b4:	460a      	mov	r2, r1
 80005b6:	71fb      	strb	r3, [r7, #7]
 80005b8:	4613      	mov	r3, r2
 80005ba:	71bb      	strb	r3, [r7, #6]
	uint32_t memAddress = (block * 65536) + (sector * 4096);
 80005bc:	79fb      	ldrb	r3, [r7, #7]
 80005be:	011a      	lsls	r2, r3, #4
 80005c0:	79bb      	ldrb	r3, [r7, #6]
 80005c2:	4413      	add	r3, r2
 80005c4:	031b      	lsls	r3, r3, #12
 80005c6:	60fb      	str	r3, [r7, #12]
	W25Q_WriteEnable();
 80005c8:	f7ff ff84 	bl	80004d4 <W25Q_WriteEnable>
	SPI2_SelectSlave();
 80005cc:	f7ff fe78 	bl	80002c0 <SPI2_SelectSlave>
	SPI2_TransmitReceiveByte(ERASE_SECTOR);
 80005d0:	2020      	movs	r0, #32
 80005d2:	f7ff fe91 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte((memAddress >> 16) & 0xFF);
 80005d6:	68fb      	ldr	r3, [r7, #12]
 80005d8:	0c1b      	lsrs	r3, r3, #16
 80005da:	b2db      	uxtb	r3, r3
 80005dc:	4618      	mov	r0, r3
 80005de:	f7ff fe8b 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte((memAddress >> 8) & 0xFF);
 80005e2:	68fb      	ldr	r3, [r7, #12]
 80005e4:	0a1b      	lsrs	r3, r3, #8
 80005e6:	b2db      	uxtb	r3, r3
 80005e8:	4618      	mov	r0, r3
 80005ea:	f7ff fe85 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_TransmitReceiveByte(memAddress & 0xFF);
 80005ee:	68fb      	ldr	r3, [r7, #12]
 80005f0:	b2db      	uxtb	r3, r3
 80005f2:	4618      	mov	r0, r3
 80005f4:	f7ff fe80 	bl	80002f8 <SPI2_TransmitReceiveByte>
	SPI2_DeselectSlave();
 80005f8:	f7ff fe70 	bl	80002dc <SPI2_DeselectSlave>
	delay_ms(500);
 80005fc:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8000600:	f7ff fed6 	bl	80003b0 <delay_ms>
}
 8000604:	bf00      	nop
 8000606:	3710      	adds	r7, #16
 8000608:	46bd      	mov	sp, r7
 800060a:	bd80      	pop	{r7, pc}

0800060c <main>:
#include "LED.h"
#include "UART.h"
#include "W25Qxx.h"

int main()
{
 800060c:	b580      	push	{r7, lr}
 800060e:	b0c2      	sub	sp, #264	@ 0x108
 8000610:	af00      	add	r7, sp, #0
	uint8_t buf[256] ="The W25Q64FV (64M-bit) Serial Flash memory provides a storage solution for systems with limited space, pins and power. The 25Q series offers flexibility and performance well beyond ordinary Serial Flash devices. They are ideal for code shadowing to RAM .!!";
 8000612:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8000616:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800061a:	4a17      	ldr	r2, [pc, #92]	@ (8000678 <main+0x6c>)
 800061c:	4618      	mov	r0, r3
 800061e:	4611      	mov	r1, r2
 8000620:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000624:	461a      	mov	r2, r3
 8000626:	f000 f877 	bl	8000718 <memcpy>
	W25Q_Init();
 800062a:	f7ff ff80 	bl	800052e <W25Q_Init>
	LED_Init();
 800062e:	f7ff fdd1 	bl	80001d4 <LED_Init>
	UART2_Init();
 8000632:	f7ff ff13 	bl	800045c <UART2_Init>

	LED_Toggle();
 8000636:	f7ff fdfd 	bl	8000234 <LED_Toggle>
	W25Q_EraseSector(0, 0);
 800063a:	2100      	movs	r1, #0
 800063c:	2000      	movs	r0, #0
 800063e:	f7ff ffb5 	bl	80005ac <W25Q_EraseSector>
	for(int i = 0; i < 32768; i++)
 8000642:	2300      	movs	r3, #0
 8000644:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8000648:	e00c      	b.n	8000664 <main+0x58>
	{
		W25Q_WritePage(i, 0, 256, buf);
 800064a:	f8d7 0104 	ldr.w	r0, [r7, #260]	@ 0x104
 800064e:	1d3b      	adds	r3, r7, #4
 8000650:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8000654:	2100      	movs	r1, #0
 8000656:	f7ff ff72 	bl	800053e <W25Q_WritePage>
	for(int i = 0; i < 32768; i++)
 800065a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800065e:	3301      	adds	r3, #1
 8000660:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8000664:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8000668:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800066c:	dbed      	blt.n	800064a <main+0x3e>
	}
	LED_Toggle();;
 800066e:	f7ff fde1 	bl	8000234 <LED_Toggle>



	while(1)
 8000672:	bf00      	nop
 8000674:	e7fd      	b.n	8000672 <main+0x66>
 8000676:	bf00      	nop
 8000678:	0800074c 	.word	0x0800074c

0800067c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800067c:	480d      	ldr	r0, [pc, #52]	@ (80006b4 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800067e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8000680:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000684:	480c      	ldr	r0, [pc, #48]	@ (80006b8 <LoopForever+0x6>)
  ldr r1, =_edata
 8000686:	490d      	ldr	r1, [pc, #52]	@ (80006bc <LoopForever+0xa>)
  ldr r2, =_sidata
 8000688:	4a0d      	ldr	r2, [pc, #52]	@ (80006c0 <LoopForever+0xe>)
  movs r3, #0
 800068a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800068c:	e002      	b.n	8000694 <LoopCopyDataInit>

0800068e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800068e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000690:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000692:	3304      	adds	r3, #4

08000694 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000694:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000696:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000698:	d3f9      	bcc.n	800068e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800069a:	4a0a      	ldr	r2, [pc, #40]	@ (80006c4 <LoopForever+0x12>)
  ldr r4, =_ebss
 800069c:	4c0a      	ldr	r4, [pc, #40]	@ (80006c8 <LoopForever+0x16>)
  movs r3, #0
 800069e:	2300      	movs	r3, #0
  b LoopFillZerobss
 80006a0:	e001      	b.n	80006a6 <LoopFillZerobss>

080006a2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80006a2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80006a4:	3204      	adds	r2, #4

080006a6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80006a6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80006a8:	d3fb      	bcc.n	80006a2 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80006aa:	f000 f811 	bl	80006d0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80006ae:	f7ff ffad 	bl	800060c <main>

080006b2 <LoopForever>:

LoopForever:
  b LoopForever
 80006b2:	e7fe      	b.n	80006b2 <LoopForever>
  ldr   r0, =_estack
 80006b4:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 80006b8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80006bc:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 80006c0:	08000854 	.word	0x08000854
  ldr r2, =_sbss
 80006c4:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 80006c8:	2000001c 	.word	0x2000001c

080006cc <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80006cc:	e7fe      	b.n	80006cc <ADC_IRQHandler>
	...

080006d0 <__libc_init_array>:
 80006d0:	b570      	push	{r4, r5, r6, lr}
 80006d2:	4d0d      	ldr	r5, [pc, #52]	@ (8000708 <__libc_init_array+0x38>)
 80006d4:	4c0d      	ldr	r4, [pc, #52]	@ (800070c <__libc_init_array+0x3c>)
 80006d6:	1b64      	subs	r4, r4, r5
 80006d8:	10a4      	asrs	r4, r4, #2
 80006da:	2600      	movs	r6, #0
 80006dc:	42a6      	cmp	r6, r4
 80006de:	d109      	bne.n	80006f4 <__libc_init_array+0x24>
 80006e0:	4d0b      	ldr	r5, [pc, #44]	@ (8000710 <__libc_init_array+0x40>)
 80006e2:	4c0c      	ldr	r4, [pc, #48]	@ (8000714 <__libc_init_array+0x44>)
 80006e4:	f000 f826 	bl	8000734 <_init>
 80006e8:	1b64      	subs	r4, r4, r5
 80006ea:	10a4      	asrs	r4, r4, #2
 80006ec:	2600      	movs	r6, #0
 80006ee:	42a6      	cmp	r6, r4
 80006f0:	d105      	bne.n	80006fe <__libc_init_array+0x2e>
 80006f2:	bd70      	pop	{r4, r5, r6, pc}
 80006f4:	f855 3b04 	ldr.w	r3, [r5], #4
 80006f8:	4798      	blx	r3
 80006fa:	3601      	adds	r6, #1
 80006fc:	e7ee      	b.n	80006dc <__libc_init_array+0xc>
 80006fe:	f855 3b04 	ldr.w	r3, [r5], #4
 8000702:	4798      	blx	r3
 8000704:	3601      	adds	r6, #1
 8000706:	e7f2      	b.n	80006ee <__libc_init_array+0x1e>
 8000708:	0800084c 	.word	0x0800084c
 800070c:	0800084c 	.word	0x0800084c
 8000710:	0800084c 	.word	0x0800084c
 8000714:	08000850 	.word	0x08000850

08000718 <memcpy>:
 8000718:	440a      	add	r2, r1
 800071a:	4291      	cmp	r1, r2
 800071c:	f100 33ff 	add.w	r3, r0, #4294967295
 8000720:	d100      	bne.n	8000724 <memcpy+0xc>
 8000722:	4770      	bx	lr
 8000724:	b510      	push	{r4, lr}
 8000726:	f811 4b01 	ldrb.w	r4, [r1], #1
 800072a:	f803 4f01 	strb.w	r4, [r3, #1]!
 800072e:	4291      	cmp	r1, r2
 8000730:	d1f9      	bne.n	8000726 <memcpy+0xe>
 8000732:	bd10      	pop	{r4, pc}

08000734 <_init>:
 8000734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000736:	bf00      	nop
 8000738:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800073a:	bc08      	pop	{r3}
 800073c:	469e      	mov	lr, r3
 800073e:	4770      	bx	lr

08000740 <_fini>:
 8000740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000742:	bf00      	nop
 8000744:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000746:	bc08      	pop	{r3}
 8000748:	469e      	mov	lr, r3
 800074a:	4770      	bx	lr
